#!/usr/bin/env python
import itertools
import sys

def input_min_support_to_int(input:str) -> int:
    """
    Convert input for minimum support to integer ranging 0 to 100.
    If entered with %, it'll return `input` as int. Must be between 0 to 100.
    If entered without %, it'll convert `input` into float and multiply it by 100. Must be between 0.0 to 1.0.
    """
    if "%" in input:
        input_int = int(input.rstrip("%"))
        if input_int >= 0 and input_int <= 100:
            return input_int
        else:
            raise ValueError("Minimum support must be between 0% and 100%")
    else:
        input_float = float(input)
        if input_float >= 0.0 and input_float <= 1.0:
            return round(input_float*100)
        else:
            raise ValueError("Minimum support must be between 0.0 and 1.0")

def read_transaction_list(filename:str) -> tuple[list[set], set]:
    """
    Input: File of `filename` that contains all transactions.
    Output: List of transactions as list[set], all items available as set
    """
    transaction_list = []
    item_set = set()
    with open(filename, "r") as transactions:
        for transaction in transactions:
            temp_set = set(transaction.rstrip('\n').split(", "))
            item_set = item_set.union(temp_set)
            transaction_list.append(temp_set)
    return transaction_list, item_set

def apriori_algorithm(transaction_list:list[set], item_set:set, min_support:int) -> list[set]:
    """
    Input: List of transactions as list[set], all items available as set, minimum support as int (between 0 and 100)
    Output: List of all frequent itemset generated by algorithm. 
    """
    k = 1
    transaction_count = len(transaction_list)
    freq_set = []
    k_freq_set = []
    forbid_set = []
    for item in item_set:
        k_freq_set.append(frozenset({item}))

    while k <= len(item_set):
        # Step 1, count apperance of each set in k_freq_set in transaction_list
        k_count = {}
        for item_iset in transaction_list:
            for k_iset in k_freq_set:
                if k_iset.issubset(item_iset):
                    k_count[k_iset] = k_count.get(k_iset, 0) + 1

        # Step 2, calculate support value for each counted set and add those whose support value is bigger than item_min to item_legal_temp
        freq_count = 0
        for k_iset, k_ival in k_count.items():
            k_support = round((k_ival/transaction_count)*100)
            if k_support >= min_support:
                freq_set.append(set(k_iset))
                freq_count += 1
            else:
                forbid_set.append(set(k_iset))
                if k == 1:
                    for s in k_iset:
                        item_set.remove(s)
        if freq_count == 0:
            break

        # Step 3, create a new set for the next k
        # All set generated using this library will become a tuple. We have to convert them into frozenset as well as check if they are a legal set
        k += 1
        k_freq_set = []
        k_freq_temp = set(itertools.combinations(item_set, k)) 
        for k_iset in k_freq_temp.copy():
            k_iset = frozenset(k_iset)
            is_freq = True # Innocent until proven guilty
            for k_iforbid in forbid_set:
                if k_iforbid.issubset(k_iset):
                    is_freq = False
                    break
            if is_freq:
                k_freq_set.append(k_iset)

    return freq_set

if __name__ == "__main__":
    transaction_list, item_set = read_transaction_list(sys.argv[1])
    result = apriori_algorithm(transaction_list, item_set, input_min_support_to_int(sys.argv[2] if len(sys.argv) > 2 else "60%"))
    print(result)